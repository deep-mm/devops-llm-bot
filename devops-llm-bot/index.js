// Git Data API use case example
// See: https://developer.github.com/v3/git/ to learn more

const { OpenAIApi, Configuration } = require("openai");
/**
 * This is the main entrypoint to your Probot app
 * @param {import('probot').Probot} app
 */
module.exports = (app) => {

  // app.on("issue_comment.edited", async (context) => {
  //   const repo = context.payload.repository.name;
  //   const owner = context.payload.repository.owner.login;
  //   const defaultBranch = "main"

  //   const repositoryTree = await context.octokit.git.getTree({
  //     repo,
  //     owner,
  //     tree_sha: "heads/" + defaultBranch,
  //   });

  //   console.log(repositoryTree.data.tree.map((item) => item.path));

  //   const languages = await context.octokit.repos.listLanguages({
  //     repo,
  //     owner,
  //   });

  //   console.log(Object.keys(languages.data));
  //   // Filter languages to only get keys

  //   // const dependencies = context.octokit.dependencyGraph.exportSbom ({
  //   //   repo,
  //   //   owner,
  //   // });

  //   // console.log(dependencies);
  // });

  app.on("issue_comment.created", async (context) => {
    if (context.payload.comment.body.startsWith("@devops-llm-bot") && context.payload.issue.pull_request!=null) {
      const repo = context.payload.repository.name;
      const owner = context.payload.repository.owner.login;

      const PRDetails = await context.octokit.pulls.get({
        owner,
        repo,
        pull_number: context.payload.issue.number,
      });

      const branch = PRDetails.data.head.ref;

      const fileDetail = await context.octokit.repos.getContent({
        owner,
        repo,
        path: ".github/workflows/build-autogenerated.yml",
        ref: branch,
      });

      let bufferObj = Buffer.from(fileDetail.data.content, 'base64')
      let fileContent = bufferObj.toString('utf-8');

      const user_comment = context.payload.comment.body;

      const response = await update_pipeline (fileContent, user_comment);

      await context.octokit.repos.createOrUpdateFileContents({
        repo,
        owner,
        path: ".github/workflows/build-autogenerated.yml", // the path to your config file
        message: "Updating workflow file based on PR comments", // a commit message
        content: Buffer.from(response).toString("base64"),
        // the content of your file, must be base64 encoded
        branch, // the branch name we used when creating a Git reference
        sha: fileDetail.data.sha,
      });

      const issueComment = context.issue({
        body: "Updated the workflow to reflect the changes you requested.",
      });
      return context.octokit.issues.createComment(issueComment);
    }
  });

  app.on("issues.opened", async (context) => {
    if (context.payload.issue.title.startsWith("@devops-llm-bot")) {
      const issueComment = context.issue({
        body: "The bot is generating the build pipeline for this issue! \n Once generated, you will see a PR with the pipeline.",
      });
      context.octokit.issues.createComment(issueComment);

      const branch = `devops-llm-bot-${Math.floor(Math.random() * 9999)}`;
      const repo = context.payload.repository.name;
      const owner = context.payload.repository.owner.login;

      const repoContext = await context.octokit.repos.get({
        owner,
        repo,
      });

      const defaultBranch = repoContext.data.default_branch;;

      // Get current reference in Git
      const reference = await context.octokit.git.getRef({
        repo, // the repo
        owner, // the owner of the repo
        ref: "heads/" + defaultBranch,
      });
      // Create a branch
      await context.octokit.git.createRef({
        repo,
        owner,
        ref: `refs/heads/${branch}`,
        sha: reference.data.object.sha, // accesses the sha from the heads/master reference we got
      });

      const repositoryTree = await context.octokit.git.getTree({
        repo,
        owner,
        tree_sha: "heads/" + defaultBranch,
      });
  
      const repoTree = repositoryTree.data.tree.map((item) => item.path);
  
      const languages = await context.octokit.repos.listLanguages({
        repo,
        owner,
      });
  
      const languages_array = Object.keys(languages.data);

      const user_comment = context.payload.issue.body;

      const response = await generate_pipeline (repoTree, languages_array, '', user_comment);

      // create a new file
      await context.octokit.repos.createOrUpdateFileContents({
        repo,
        owner,
        path: ".github/workflows/build-autogenerated.yml", // the path to your config file
        message: "Adding build workflow", // a commit message
        content: Buffer.from(response).toString("base64"),
        // the content of your file, must be base64 encoded
        branch, // the branch name we used when creating a Git reference
      });
      // create a PR from that branch with the commit of our added file
      await context.octokit.pulls.create({
        repo,
        owner,
        title: "GitHub Build Workflow", // the title of the PR
        head: branch, // the branch our chances are on
        base: defaultBranch, // the branch to which you want to merge your changes
        body: "Adding build workflow for application", // the body of your PR,
        maintainer_can_modify: true, // allows maintainers to edit your app's PR
      });
    }
  });
  // For more information on building apps:
  // https://probot.github.io/docs/

  // To get your app running against GitHub, see:
  // https://probot.github.io/docs/development/
};

async function generate_pipeline (repoTree, languages, dependencies, user_comment) {
  const configuration = new Configuration({
    apiKey: process.env.OPENAI_API_KEY,
  });
  const openai = new OpenAIApi(configuration);
  
  if (!configuration.apiKey) {
    res.status(500).json({
      error: {
        message: "OpenAI API key not configured, please follow instructions in README.md",
      }
    });
    return;
  }

  const completion = await openai.createChatCompletion({
    model: "gpt-3.5-turbo-16k",
    temperature: 0.2,
    max_tokens: 1000,
    messages: [
      {
        "role": "system",
        "content": "Your name is Dev bot. You are a brilliant and meticulous engineer assigned to write a GitHub Actions workflow in YAML for the following Github Repository. When you write code, the code works on the first try, is syntactically perfect and is fully complete. The workflow should be able to build and run the application and run the tests if present in the repository. Take into account the current repository's language, frameworks, and dependencies. "
      },
      {
        "role": "user",
        "content": generateContent(repoTree, languages, dependencies, user_comment),
      },
    ]
  });
  return completion.data.choices[0].message['content'];
  
}

function generateContent(repoTree, languages, dependencies, user_comment) {

  return `Analyze the github repository structure, language, framework and dependencies provide below to create a github action build workflow. You will provide the github action workflow as the answer. Only include the yaml file in the output. Do not add any other text before or after the code.
      Take user requests into consideration, but ensure that you only restrict the output to build and test workflow, there should not be any deploy steps in the workflow.    

      User requests:
      ${user_comment}

      Repository structure:
      ${repoTree}

      Languages: 
      ${languages}

      Dependencies: 
      ${dependencies}`
}

async function update_pipeline (old_workflow, user_comment) {
  const configuration = new Configuration({
    apiKey: process.env.OPENAI_API_KEY,
  });
  const openai = new OpenAIApi(configuration);
  
  if (!configuration.apiKey) {
    res.status(500).json({
      error: {
        message: "OpenAI API key not configured, please follow instructions in README.md",
      }
    });
    return;
  }

  const completion = await openai.createChatCompletion({
    model: "gpt-3.5-turbo-16k",
    temperature: 0.2,
    max_tokens: 1000,
    messages: [
      {
        "role": "system",
        "content": "Your name is Dev bot. You are a brilliant and meticulous engineer assigned to write a GitHub Actions workflow in YAML for the following Github Repository. When you write code, the code works on the first try, is syntactically perfect and is fully complete. The workflow should be able to build and run the application and run the tests if present in the repository. Take into account the current repository's language, frameworks, and dependencies. "
      },
      {
        "role": "user",
        "content": generateUpdateWorkflowContent(old_workflow, user_comment),
      },
    ]
  });
  return completion.data.choices[0].message['content'];
  
}

function generateUpdateWorkflowContent(old_workflow, user_comment) {

  return `Analyze the existing github workflow and user requested changes provided below to create a github action build workflow. You will provide the github action workflow as the answer. Only include the yaml file in the output. Do not add any other text before or after the code.
      Take user requests into consideration, but ensure that you only restrict the output to build and test workflow, there should not be any deploy steps in the workflow.    

      Existing workflow:
      ${old_workflow}

      User requests:
      ${user_comment}`
}